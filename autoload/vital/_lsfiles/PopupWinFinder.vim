" ___vital___
" NOTE: lines between '" ___vital___' is generated by :Vitalize.
" Do not modify the code nor insert new lines before '" ___vital___'
function! s:_SID() abort
  return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
endfunction
execute join(['function! vital#_lsfiles#PopupWinFinder#import() abort', printf("return map({'open': ''}, \"vital#_lsfiles#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
delfunction s:_SID
" ___vital___

function! s:open(lines, options) abort
    let s:options = a:options
    let s:options['cursorline'] = get(a:options, 'cursorline', 1)
    let s:options['curr_filter_text'] = get(a:options, 'curr_filter_text', '')
    let s:options['prev_filter_text'] = get(a:options, 'prev_filter_text', '')
    let s:no_matches = 'no matches'
    let s:search_mode = v:false
    let s:title = get(a:options, 'title')
    let s:user_callback = get(a:options, 'callback')
    let s:result_winid = popup_menu(a:lines, {})
    let s:search_winid = -1
    let s:orig_lines = a:lines
    call s:_hide_cursor()
    call s:_update_lines(v:true)
    call s:_set_options()
    call s:_set_cursorline()
    return s:result_winid
endfunction




function! s:_hide_cursor() abort
    call setwinvar(s:result_winid, 'cursor_hl', s:_parse_hl('Cursor'))
    highlight Cursor guifg=NONE guibg=NONE ctermfg=NONE ctermbg=NONE
endfunction

function! s:_show_cursor(winid) abort
    execute getwinvar(a:winid, 'cursor_hl')
endfunction

function! s:_parse_hl(name) abort
    let m = matchlist(trim(execute('highlight ' .. a:name)), '^\(\i\+\)\s\+xxx\s\+\(.*\)$')
    if !empty(m)
        if m[2] == 'cleared'
            return printf('highlight clear %s', m[1])
        elseif m[2] =~ '^links to'
            return printf('highlight link %s %s', m[1], split(m[2])[-1])
        else
            return printf('highlight %s %s', m[1], m[2])
        endif
    endif
    return ''
endfunction

function! s:_callback(winid, key) abort
    call popup_close(s:search_winid)
    call s:_show_cursor(a:winid)
    call call(s:user_callback, [(a:winid), (a:key)])
endfunction

function! s:_set_options() abort
    if s:result_winid != -1
        let orig_len = len(s:orig_lines)
        let filter_lines = getbufline(winbufnr(s:result_winid), 1, '$')
        let filter_len = (get(filter_lines, 0, '') == s:no_matches) ? 0 : len(filter_lines)
        call popup_setoptions(s:result_winid, #{
            \ title: printf('%s(%d/%d)', s:title, filter_len, orig_len),
            \ filter: function('s:_filter'),
            \ callback: function('s:_callback'),
            \ zindex: 100,
            \ maxheight: &lines / 3,
            \ maxwidth: &columns - 4,
            \ padding: [(s:search_mode ? 1 : 0), 1, 0, 1],
            \ pos: 'center',
            \ border: [1,1,1,1],
            \ borderchars: [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
            \ minwidth: len(s:options['curr_filter_text']) + 1,
            \ })
    endif
    if s:search_winid != -1
        call popup_settext(s:search_winid, '/' .. s:options['curr_filter_text'])
        let parent_pos = popup_getpos(s:result_winid)
        call popup_setoptions(s:search_winid, #{
            \ pos: 'topleft',
            \ zindex: 200,
            \ line: parent_pos['line'] + 1,
            \ col: parent_pos['col'] + 2,
            \ minwidth: parent_pos['core_width'],
            \ padding: [0, 0, 0, 0],
            \ border: [0, 0, 0, 0],
            \ })
    endif
endfunction

function! s:_filter(winid, key) abort
    "echo printf('%x', char2nr(a:key))
    if s:search_mode
        let s:options['curr_filter_text'] = get(getbufline(winbufnr(s:search_winid), 1, 1), 0, '/')[1:]
        let chars = split(s:options['curr_filter_text'], '\zs')
        if ("\<esc>" == a:key) || ("\<cr>" == a:key)
            let s:search_mode = v:false
            call popup_close(s:search_winid)
            let s:search_winid = -1
            call s:_set_options()
            return 1
        else
            if 21 == char2nr(a:key)
                let s:options['curr_filter_text'] = ''
            elseif (8 == char2nr(a:key)) || (128 == char2nr(a:key))
                if 0 < len(chars)
                    if 1 == len(chars)
                        let chars = []
                    else
                        let chars = chars[:len(chars) - 2]
                    endif
                else
                    let chars = []
                    let s:search_mode = v:false
                    call popup_close(s:search_winid)
                    let s:search_winid = -1
                endif
                let s:options['curr_filter_text'] = join(chars, '')
            elseif (0x20 <= char2nr(a:key)) && (char2nr(a:key) <= 0x7f)
                let s:options['curr_filter_text'] = s:options['curr_filter_text'] .. a:key
            endif
            let s:options['curr_filter_text'] = trim(s:options['curr_filter_text'])
            call s:_update_lines(v:false)
            call s:_set_options()
            return 1
        endif
    else
        if '/' ==# a:key
            let s:search_mode = v:true
            call s:_update_lines(v:false)
            let parent_pos = popup_getpos(a:winid)
            let s:search_winid = popup_create('', {})
            call s:_set_options()
            return 1
        elseif 'q' ==# a:key
            return popup_filter_menu(a:winid, "\<esc>")
        elseif 'g' ==# a:key
            echo printf('%x', line('$', a:winid))
            let s:options['cursorline'] = 1
            call s:_set_cursorline()
            return 1
        elseif 'G' ==# a:key
            let s:options['cursorline'] = line('$', a:winid)
            call s:_set_cursorline()
            return 1
        elseif 'j' ==# a:key
            let s:options['cursorline'] = line('.', a:winid) + 1
            if line('$', a:winid) < s:options['cursorline']
                let s:options['cursorline'] = line('$', a:winid)
            endif
            call s:_set_cursorline()
            return 1
        elseif 'k' ==# a:key
            let s:options['cursorline'] = line('.', a:winid) - 1
            if s:options['cursorline'] < 1
                let s:options['cursorline'] = 1
            endif
            call s:_set_cursorline()
            return 1
        else
            return popup_filter_menu(a:winid, a:key)
        endif
    endif
endfunction

function! s:_ignorecase_filter_text() abort
    if empty(s:options['curr_filter_text'])
        return ''
    else
        return (&ignorecase ? '\c' : '') .. s:options['curr_filter_text']
    endif
endfunction

function! s:_update_lines(force) abort
    if (s:options['prev_filter_text'] != s:options['curr_filter_text']) || a:force
        let s:options['prev_filter_text'] = s:options['curr_filter_text']
        let lines = filter(deepcopy(s:orig_lines), { i,x -> -1 != match(x, s:_ignorecase_filter_text()) })
        call win_execute(s:result_winid, 'call clearmatches()')
        if !empty(lines)
            call popup_settext(s:result_winid, lines)
            call win_execute(s:result_winid, printf("call matchadd('Search', %s)", string(s:_ignorecase_filter_text())))
        else
            call popup_settext(s:result_winid, s:no_matches)
        endif
        call s:_set_options()
        redraw
    endif
endfunction

function! s:_set_cursorline() abort
    call win_execute(s:result_winid, printf('call setpos(".", [0, %d, 0, 0])', s:options['cursorline']))
endfunction

